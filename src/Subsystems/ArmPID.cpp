// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.



#include "ArmPID.h"
#include "../RobotMap.h"
#include "SmartDashboard/SmartDashboard.h"
#include "LiveWindow/LiveWindow.h"
#include "../Robot.h"
#include "../OI.h"

namespace
{
	const double c_sensorVoltRange = 4.0; //0.5 - 4.5
	const double c_sensorAngleRange = 360.0;

#ifdef PracticeBot
	const double c_ArmAngleDifference = 21;// positive if angle is above horizontal -- started at 37, 46.5
#endif

#ifdef CompBot
	const double c_ArmAngleDifference = 47.5;// positive if angle is above horizontal
#endif
}
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
ArmPID::ArmPID() : PIDSubsystem("ArmPID", 1.0, 0.0, 0.0) {
    SetAbsoluteTolerance(0.2); //angle  must be within .2 degrees
    GetPIDController().get()->SetContinuous(false);
    LiveWindow::GetInstance()->AddActuator("ArmPID", "PIDSubsystem Controller", GetPIDController());


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    armMotorRight = RobotMap::armPIDArmMotorRight;
    armMotorLeft = RobotMap::armPIDArmMotorLeft;
    lowBarProx1 = RobotMap::armPIDLowBarProx1;
    lowBarProx2 = RobotMap::armPIDLowBarProx2;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    armAngle = RobotMap::armPIDArmAngle;
    light1 = RobotMap::lightOutput1;
    light2 = RobotMap::lightOutput2;

    // Use these to get going:
    // SetSetpoint() -  Sets where the PID controller should move the system
    //                  to
     Disable(); // - Enables the PID controller.
     m_commandIsActive = false;
     m_manualOverride = false;
}

double ArmPID::ReturnPIDInput() {

	return GetArmAngle();

    // Return your input value for the PID loop
    // e.g. a sensor, like a potentiometer:
    // yourPot->SetAverageVoltage() / kYourMaxVoltage;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
    //    return armAngle->PIDGet();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
}

bool ArmPID::SetArmAngle(float angle){ // we are NOT using PID for arm so this is all commented out - Ask Kellie before uncommenting
//	double m_Angle = angle;
//	double m_goingUp = false;
//
//		m_goingUp = (Robot::armPID.get()->GetArmAngle() > m_Angle ? true : false); //THIS DOES NOT WORK because it just keeps going down (opposite of previous problem)
//		float currentAngle = Robot::armPID.get()->GetArmAngle();
//
//		Robot::armPID.get()->SetCommandActive(true);
//
//		double output = 0;
//
//			if(currentAngle < m_Angle)
//			{
//				//go up
//				if(currentAngle < 20)
//				{
//					output = -0.3;
//				}
//				else
//				{
//					output = -1.0;
//				}
//			}
//			else if (currentAngle > m_Angle){
//				if (currentAngle < 20)
//				{
//					output = 0.3;
//				}
//				else
//				{
//					output = 1.0;
//				}
//			}
//
//			Robot::armPID.get()->UsePIDOutput(output);
//
//		Robot::armPID.get()->UsePIDOutput(output);
//
//
//		currentAngle = Robot::armPID.get()->GetArmAngle();
//			if(m_goingUp && (currentAngle > m_Angle))
//			{
//				return true;
//				Robot::armPID.get()->UsePIDOutput(0);
//				Robot::armPID.get()->SetCommandActive(false);
//			}
//			else if(!m_goingUp && (currentAngle < m_Angle))
//			{
//				return true;
//				Robot::armPID.get()->UsePIDOutput(0);
//				Robot::armPID.get()->SetCommandActive(false);
//			}
//			else
//			{
//				return false;
//			}
//

//	GetPIDController().get()->Disable();
//	GetPIDController().get()->SetSetpoint(convertAngleToVolts(angle));
//	GetPIDController().get()->Enable();
	return false;
}


float ArmPID::GetArmAngle(){
	float angle = convertVoltsToAngle(armAngle.get()->GetVoltage());
	//std::cout << " Get Arm Angle : " << angle;
	//std::cout << " Return Arm Angle : " <<  180 - angle - c_ArmAngleDifference;
	return 180 - angle - c_ArmAngleDifference;
}

double ArmPID::convertAngleToVolts(double angle)
{
	return (((c_sensorVoltRange/c_sensorAngleRange)*(angle))+.5);
}

double ArmPID::convertVoltsToAngle(double volts)
{
	return (((c_sensorAngleRange/c_sensorVoltRange)*(volts-.5)));
}

void ArmPID::UsePIDOutput(double output) {
	if(!m_manualOverride && !AngleCheck(output))
	{
		output = 0;
	}
    // Use output to drive your system, like a motor
    // e.g. yourMotor->Set(output);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
    armMotorRight->PIDWrite(output);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT

    armMotorLeft->PIDWrite(-output);
}

void ArmPID::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void ArmPID::ManualArmControl(double output, bool override) //will not set output if command is running
{
	if(!m_commandIsActive)
	{
		double allowed = output;
		if(fabs(output) < .2) //deadband
		{
			allowed = 0;
		}
		if(!override && !AngleCheck(allowed))
		{
			allowed = 0;
		}
		m_manualOverride = override;
//	    armMotorRight->PIDWrite(output);
//	    armMotorLeft->PIDWrite(-output);
		UsePIDOutput(allowed);
	}
	else
	{
		m_manualOverride = false;
	}


}

bool ArmPID::AngleCheck(double output)
{
	std::cout << "Arm Angle: "<< GetArmAngle() << ", \tOutput: " << output << "\tAngle Check: ";

	if(((GetArmAngle() > 70) && (output < 0)) ||
		((GetArmAngle() < -4) && (output > 0))) // add override switch check
	{
		std::cout << "False";
		return false;
	}
	std::cout << "True";
	return true;
}

void ArmPID::SetCommandActive(bool active)
{
	m_commandIsActive = active;
}

bool ArmPID::AreLowBarSensorsTripped(){
	if (lowBarProx1->Get() || lowBarProx2->Get()) {
			return true;
		}
		else {
			return false;
		}
}

void ArmPID::SetArmLights(ArmLight color){
	bool light1Val, light2Val;
	GetColor(color, light1Val, light2Val);
	light1.get()->Set(light1Val);
	light2.get()->Set(light2Val);
}

//void ArmPID::SetArmLightRight(ArmLight color){
//	light2.get()->Set(GetColor(color));
//}
//
//void ArmPID::SetArmLightLeft(ArmLight color){
//	light1.get()->Set(GetColor(color));
//}

double ArmPID::GetColor(ArmLight color, bool &light1Val, bool &light2Val){
	switch (color){
		default:
		case Light_Off:
			light1Val = false;
			light2Val = false;
			return 0;
			break;
		case Light_Purple:
			light1Val = true;
			light2Val = true;
			return 1;
			break;
		case Light_Blue:
			light1Val = true;
			light2Val = false;
			return .5;
			break;
		case Light_Red:
			light1Val = false;
			light2Val = true;
			return .2;
			break;
	}
}

void ArmPID::SetArmLightsBlue(){
	SetArmLights(Light_Blue);
//	light1.get()->Set(0);
//	light2.get()->Set(1);
}

void ArmPID::SetArmLightsPurple(){
	SetArmLights(Light_Purple);
//	light1.get()->Set(1);
//	light2.get()->Set(1);
}

//void ArmPID::SetArmLightsPurpleFlashy(){
//	light1.get()->Set(0.5);
//	light2.get()->Set(1);
//}

void ArmPID::SetArmLightsRed(){
	SetArmLights(Light_Red);
//	light1.get()->Set(1);
//	light2.get()->Set(0);
}
