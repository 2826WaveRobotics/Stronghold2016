/// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"

#include "Commands/AutoDrawbridge.h"
#include "Commands/AutoChevalDeFrise.h"
#include "Commands/AutoLowBar.h"
#include "Commands/AutoMoat.h"
#include "Commands/AutoPortcullis.h"
#include "Commands/AutoRamparts.h"
#include "Commands/AutoRockWall.h"
#include "Commands/AutoRoughTerrain.h"
#include "Commands/AutoSallyPort.h"
#include "Commands/AutonomousCommand.h"
#include "Commands/StartingLocation.h"
#include "Commands/FireSequence.h"
#include "Commands/SetArmPosition.h"
#include "Commands/SetHoodPosition.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<ArmPID> Robot::armPID;
std::shared_ptr<CompressorSubsystem> Robot::compressorSubsystem;
std::shared_ptr<DrivePID> Robot::drivePID;
std::shared_ptr<Hood> Robot::hood;
std::shared_ptr<GrappleClimb> Robot::grappleClimb;
std::shared_ptr<Intake> Robot::intake;
std::shared_ptr<ShooterTurretPID> Robot::shooterTurretPID;
std::shared_ptr<ShooterWheelPID> Robot::shooterWheelPID;
std::unique_ptr<OI> Robot::oi;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    armPID.reset(new ArmPID());
    compressorSubsystem.reset(new CompressorSubsystem());
    drivePID.reset(new DrivePID());
    hood.reset(new Hood());
    grappleClimb.reset(new GrappleClimb());
    intake.reset(new Intake());
    shooterTurretPID.reset(new ShooterTurretPID());
    shooterWheelPID.reset(new ShooterWheelPID());
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());


	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

	SmartDashboard::init();

	m_defenseSelector = new SendableChooser();
	m_locationSelector = new SendableChooser();

	m_defenseSelector->AddDefault("Default to Low Bar", new AutoLowBar());
	m_defenseSelector->AddObject("Low Bar", new AutoLowBar());
	m_defenseSelector->AddObject("Portcullis", new AutoPortcullis());
	m_defenseSelector->AddObject("Cheval De Frise", new AutoChevalDeFrise());
	m_defenseSelector->AddObject("Ramparts", new AutoRamparts());
	m_defenseSelector->AddObject("Moat", new AutoMoat());
	m_defenseSelector->AddObject("Sally Port", new AutoSallyPort());
	m_defenseSelector->AddObject("Drawbridge", new AutoDrawbridge());
	m_defenseSelector->AddObject("Rock Wall", new AutoRockWall());
	m_defenseSelector->AddObject("Rough Terrain", new AutoRoughTerrain());
	SmartDashboard::PutData("Auto Modes", m_defenseSelector);

	m_locationSelector->AddDefault("Default to 1", new StartingLocation(1));
	m_locationSelector->AddObject("1", new StartingLocation(1));
	m_locationSelector->AddObject("2", new StartingLocation(2));
	m_locationSelector->AddObject("3", new StartingLocation(3));
	m_locationSelector->AddObject("4", new StartingLocation(4));
	m_locationSelector->AddObject("5", new StartingLocation(5));
	SmartDashboard::PutData("Starting Location", m_locationSelector);

	//SmartDashboard::PutNumber("Test Data", 1.23);
  }

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){
	compressorSubsystem->StopCompressor();
	drivePID.get()->ResetPitchAndRoll();
}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();

//	std::cout << "Distance = " << drivePID.get()->GetDistanceTraveled() // << ", \tLow Bar Prox R " << RobotMap::armPIDLowBarProx1.get()->Get()
//			<<", \tLow Bar Prox L " << RobotMap::armPIDLowBarProx2.get()->Get() << ", \tBall Detect "<< RobotMap::intakeBallDetector.get()->Get()
//			<<", \tShooter Wheel " << RobotMap::shooterWheelPIDSpeedCounter.get()->Get() << ", Speed " << 60/RobotMap::shooterWheelPIDSpeedCounter.get()->GetPeriod();
//		std::cout<<"  Shooter Wheel PID Input: "<<Robot::shooterWheelPID.get()->ReturnPIDInput();
//		<< "\tYaw = " << drivePID.get()->GetYaw() << "\tPitch = " << drivePID.get()->GetPitch()
//		<< "\tBall Detect = " << intake.get()->IsBallDetected();
//	std::cout<<" Kiran's Arm Angle  " << armPID.get()->GetArmAngle();
}

void Robot::AutonomousInit() {
	std::cout << "AutonomousInit() started " << std::endl;
	compressorSubsystem->StartCompressor();

	Command* locationCommand = (Command *) m_locationSelector->GetSelected();
	if(NULL != locationCommand)
	{
		std::cout << "  Running locationCommand" << std::endl;
		locationCommand->Start();
	}
	else
	{
		std::cout << "  locationCommand is NULL" << std::endl;
	}

	autonomousCommand.reset((Command*)(m_defenseSelector->GetSelected()));

	if (autonomousCommand.get() != nullptr)
	{
		std::cout << "  Running autonomousCommand" << std::endl;
		autonomousCommand->Start();
	}
	else
	{
		std::cout << "  autonomousCommand is NULL" << std::endl;
	}

}

void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Cancel();

	compressorSubsystem->StartCompressor();

	m_armAngleIntakeCommand.reset(new SetArmPosition(12));
	m_armAngleIntakeReset = true;

	m_triggerHoodStow.reset(new SetHoodPosition(Hood_Stow));
	m_triggerHoodMedium.reset(new SetHoodPosition(Hood_Medium));
	m_triggerHoodHigh.reset(new SetHoodPosition(Hood_High));
	m_triggerHoodReset = true;

	std::cout << "Teleop Init" << std::endl;

}


void Robot::TeleopPeriodic() {

	Scheduler::GetInstance()->Run();

	//std::cout<<" Low Bar Prox 1 : " << Robot::armPID.get()->lowBarProx1->Get() << " Low Bar Prox 2  : " << Robot::armPID.get()->lowBarProx2->Get();

	float rightTrigger = oi.get()->getDriverJoystick()->GetRawAxis(3);
	float leftTrigger = oi.get()->getDriverJoystick()->GetRawAxis(2);

	//CHeck to see if the command needs to be started
	if((rightTrigger > 0.5) && (leftTrigger < 0.15))
	{
		if(m_armAngleIntakeReset)
		{
			m_armAngleIntakeCommand->Start();
			m_armAngleIntakeReset = false;
		}
	}
	else
	{
		//Trigger has been released
		m_armAngleIntakeReset = true;
	}

	//Run intake
	if((rightTrigger > .15) && (leftTrigger < 0.15))
	{
		//Only turn the intake on while no ball is in the collector
		if(intake.get()->IsBallDetected())
		{
			intake.get()->SetIntakeOff();
			intake.get()->SetSecondaryOff();
		}
		else
		{
			//Run the intake and shintake until the ball sensors trip
			intake.get()->SetIntakeOn();
			intake.get()->SetSecondaryOn();
		}
		shooterTurretPID.get()->SetTurretCylinder(Turret_Straight);
	}
	else if ((leftTrigger > .5) && (rightTrigger < 0.15)){
		intake.get()->SetIntakeOut();
	}
	else {
		intake.get()->SetIntakeOff();
	}



	//Drive

//	float leftDrive = oi.get()->getDriverJoystick()->GetRawAxis(1);
//	float rightDrive = oi.get()->getDriverJoystick()->GetRawAxis(5); //tank drive, currently disabled for arcade drive
//	drivePID.get()->robotDrive41.get()->TankDrive(leftDrive, rightDrive);

	//double intakeButton = oi.get()->getDriverJoystick()->GetRawAxis(3);


//	/*std::cout << "Distance = " << */drivePID.get()->GetDistanceTraveled()/* << std::endl*/;

	float arcadeDrive = oi.get()->getDriverJoystick()->GetRawAxis(1);
	float arcadeTurn = oi.get()->getDriverJoystick()->GetRawAxis(4);
	drivePID.get()->robotDrive41.get()->ArcadeDrive(arcadeDrive, arcadeTurn);


	//Arm

	//bool rightButton = oi->getDriverJoystick()->GetRawButton(6);
	float armMotorPower = oi.get()->getOperatorJoystick()->GetRawAxis(1);
	bool override = oi.get()->getOperatorJoystick()->GetRawButton(8);
	armPID.get()->ManualArmControl(armMotorPower, override);



	float longAngle = oi->getOperatorJoystick()->GetRawAxis(3);
	float shortAngle = oi->getOperatorJoystick()->GetRawAxis(2);
	if (fabs(longAngle) > .15) {
		if(m_triggerHoodReset)
		{
			m_triggerHoodMedium->Start();
			shooterWheelPID.get()->SetSequenceSpeed(Long_Shot);
			m_triggerHoodReset = false;
		}
		shooterTurretPID.get()->SetTurretCylinder(Turret_Angled);
		// same as FireSequence(Hood_Medium, Turret_Angled, Long_Shot);
	}
	else if (fabs(shortAngle) > .15){
		if(m_triggerHoodReset)
		{
			m_triggerHoodHigh->Start();
			shooterWheelPID.get()->SetSequenceSpeed(Short_Shot);
			m_triggerHoodReset = false;
		}
		shooterTurretPID.get()->SetTurretCylinder(Turret_Angled);
		// same as FireSequence(Hood_Stow, Turret_Angled, Short_Shot);
	}
	else {
		if(!m_triggerHoodReset)
		{
			m_triggerHoodStow->Start();
			shooterWheelPID.get()->SetSequenceSpeed(Idle_Shot);
			m_triggerHoodReset = true;
		}
		shooterTurretPID.get()->SetTurretCylinder(Turret_Straight);
	}





//	std::cout<<", \tShooter Wheel Speed" << Robot::shooterWheelPID.get()->ReturnPIDInput();

			//<< ", \tShooter Wheel " << RobotMap::shooterWheelPIDSpeedCounter.get()->Get();

	//Turret -- operator

//	double turretPosition = oi.get()->getOperatorJoystick()->GetRawAxis(4);
//	//shooterTurretPID.get()->SetTurretPosition(turretPosition/2);
//	RobotMap::shooterTurretPIDTurretMotor.get()->Set(turretPosition/2);

	//std::cout << std::endl;


	Wait(.005);



}

void Robot::TestPeriodic() {
	lw->Run();
}

START_ROBOT_CLASS(Robot);

