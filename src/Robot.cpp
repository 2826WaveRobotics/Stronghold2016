/// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"

#include "Commands/AutoDrawbridge.h"
#include "Commands/AutoChevalDeFrise.h"
#include "Commands/AutoLowBar.h"
#include "Commands/AutoMoat.h"
#include "Commands/AutoPortcullis.h"
#include "Commands/AutoRamparts.h"
#include "Commands/AutoRockWall.h"
#include "Commands/AutoRoughTerrain.h"
#include "Commands/AutoSallyPort.h"
#include "Commands/AutonomousCommand.h"
#include "Commands/StartingLocation.h"
#include "Commands/FireSequence.h"
#include "Commands/SetArmPosition.h"
#include "Commands/SetHoodPosition.h"
#include "Commands/BlueAllianceColor.h"
#include "Commands/RedAllianceColor.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<ArmPID> Robot::armPID;
std::shared_ptr<CompressorSubsystem> Robot::compressorSubsystem;
std::shared_ptr<DrivePID> Robot::drivePID;
std::shared_ptr<Hood> Robot::hood;
std::shared_ptr<GrappleClimb> Robot::grappleClimb;
std::shared_ptr<Intake> Robot::intake;
std::shared_ptr<ShooterTurretPID> Robot::shooterTurretPID;
std::shared_ptr<ShooterWheelPID> Robot::shooterWheelPID;
std::unique_ptr<OI> Robot::oi;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    armPID.reset(new ArmPID());
    compressorSubsystem.reset(new CompressorSubsystem());
    drivePID.reset(new DrivePID());
    hood.reset(new Hood());
    grappleClimb.reset(new GrappleClimb());
    intake.reset(new Intake());
    shooterTurretPID.reset(new ShooterTurretPID());
    shooterWheelPID.reset(new ShooterWheelPID());
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());


	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

	SmartDashboard::init();

	m_defenseSelector = new SendableChooser();
	m_locationSelector = new SendableChooser();
	m_allianceSelector = new SendableChooser();

	m_defenseSelector->AddDefault("Default to Low Bar", new AutoLowBar());
	m_defenseSelector->AddObject("Low Bar", new AutoLowBar());
	m_defenseSelector->AddObject("Portcullis", new AutoPortcullis());
	m_defenseSelector->AddObject("Cheval De Frise", new AutoChevalDeFrise());
	m_defenseSelector->AddObject("Ramparts", new AutoRamparts());
	m_defenseSelector->AddObject("Moat", new AutoMoat());
	m_defenseSelector->AddObject("Sally Port", new AutoSallyPort());
	m_defenseSelector->AddObject("Drawbridge", new AutoDrawbridge());
	m_defenseSelector->AddObject("Rock Wall", new AutoRockWall());
	m_defenseSelector->AddObject("Rough Terrain", new AutoRoughTerrain());
	SmartDashboard::PutData("Auto Modes", m_defenseSelector);

	m_locationSelector->AddDefault("Default to 1", new StartingLocation(1));
	m_locationSelector->AddObject("1", new StartingLocation(1));
	m_locationSelector->AddObject("2", new StartingLocation(2));
	m_locationSelector->AddObject("3", new StartingLocation(3));
	m_locationSelector->AddObject("4", new StartingLocation(4));
	m_locationSelector->AddObject("5", new StartingLocation(5));
	SmartDashboard::PutData("Starting Location", m_locationSelector);

	m_allianceSelector->AddDefault("Default to Red", new RedAllianceColor() );
	m_allianceSelector->AddObject("Red Alliance", new RedAllianceColor());
	m_allianceSelector->AddObject("Blue Alliance", new BlueAllianceColor());
	SmartDashboard::PutData("Light Colors!", m_allianceSelector);

	//SmartDashboard::PutNumber("Test Data", 1.23);
  }

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){
	compressorSubsystem->StopCompressor();
	drivePID.get()->ResetPitchAndRoll();
}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();


	std::cout << "Distance = " << drivePID.get()->GetDistanceTraveled() << ", \tLow Bar Prox R " << RobotMap::armPIDLowBarProx1.get()->Get()
			<<", \tLow Bar Prox L " << RobotMap::armPIDLowBarProx2.get()->Get() << ", \tBall Detect "<< RobotMap::intakeBallDetector.get()->Get()
			/*<<", \tShooter Wheel " << RobotMap::shooterWheelPIDSpeedCounter.get()->Get() << ", /tSpeed " << 60/RobotMap::shooterWheelPIDSpeedCounter.get()->GetPeriod();*/
		<<"  \tShooter Wheel PID Input: "<<Robot::shooterWheelPID.get()->ReturnPIDInput()
		/*<< "\tYaw = " << drivePID.get()->GetYaw() << "\tPitch = " << drivePID.get()->GetPitch()*/

<<" \tArm Angle  " << armPID.get()->GetArmAngle() << "\t Are Low Bar Sensors Tripped? " << armPID.get()->AreLowBarSensorsTripped();

	std::cout << "Is Ball Detected? " << intake.get()->IsBallDetected() << std::endl;
}

void Robot::AutonomousInit() {
	std::cout << "AutonomousInit() started " << std::endl;
	compressorSubsystem->StartCompressor();

	Command* locationCommand = (Command *) m_locationSelector->GetSelected();
	if(NULL != locationCommand)
	{
		std::cout << "  Running locationCommand" << std::endl;
		locationCommand->Start();
	}
	else
	{
		std::cout << "  locationCommand is NULL" << std::endl;
	}

	autonomousCommand.reset((Command*)(m_defenseSelector->GetSelected()));

	if (autonomousCommand.get() != nullptr)
	{
		std::cout << "  Running autonomousCommand" << std::endl;
		autonomousCommand->Start();
	}
	else
	{
		std::cout << "  autonomousCommand is NULL" << std::endl;
	}

	colorRunTimer.Start();
	color = Light_Purple;

}

void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();

	std::cout<<" Pitch = " << drivePID.get()->GetPitch()<<std::endl;

	if(colorRunTimer.HasPeriodPassed(.25)){
		if(color == Light_Red){
			color = Light_Purple;
		}
		else if(color == Light_Purple){
			color = Light_Blue;
		}
		else if(color == Light_Blue){
			color = Light_Red;
		}

		colorRunTimer.Reset();
	}

}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Cancel();

	compressorSubsystem->StartCompressor();

	m_armAngleIntakeCommand.reset(new SetArmPosition(9));//7 for comp bot
	m_armAngleIntakeReset = true;

	m_triggerHoodStow.reset(new SetHoodPosition(Hood_Stow));
	m_triggerHoodMedium.reset(new SetHoodPosition(Hood_Medium));
	m_triggerHoodHigh.reset(new SetHoodPosition(Hood_High));
	m_triggerHoodReset = true;

	drivePID.get()->SetDrive_Brake(true);
	m_armWasActive = false;

	Command* allianceCommand = (Command *) m_allianceSelector->GetSelected(); //trying to do cool selecty stuff!!!
	if(NULL != allianceCommand)
	{
		std::cout << "  Running allianceCommand" << std::endl;
		allianceCommand->Start();
	}
	else
	{
		std::cout << "  allianceCommand is NULL" << std::endl;
	}

	//shooterWheelPID.get()->SetSequenceSpeed(Idle_Shot);

	std::cout << "Teleop Init" << std::endl;

	//allianceCommand.reset((Command*)(m_allianceSelector->GetSelected()));

}


void Robot::TeleopPeriodic() {

	Scheduler::GetInstance()->Run();

//	m_redAlliance->Start();

	//MOTOR STUFF

	//drivePID.get()->leftBack->GetOutputCurrent();
//
//	std::cout<< "Drive Left Front " << drivePID.get()->leftFront->GetOutputCurrent()
//			<< "\tDrive Left Back " << drivePID.get()->leftBack->GetOutputCurrent()
//			<< " \tDrive Right Front " << drivePID.get()->rightFront->GetOutputCurrent()
//			<< "\tDrive Right Back " << drivePID.get()->rightBack->GetOutputCurrent();

	//std::cout<<" Low Bar Prox 1 : " << Robot::armPID.get()->lowBarProx1->Get() << " Low Bar Prox 2  : " << Robot::armPID.get()->lowBarProx2->Get();

	float rightTrigger = oi.get()->getDriverJoystick()->GetRawAxis(3);
	float leftTrigger = oi.get()->getDriverJoystick()->GetRawAxis(2);
	bool ballDetected = intake.get()->IsBallDetected();
	bool aButton = oi.get()->getOperatorJoystick()->GetRawButton(1);
	bool xButton = oi.get()->getOperatorJoystick()->GetRawButton(3);

	//CHeck to see if the command needs to be started

	if((rightTrigger > 0.15) && (leftTrigger < 0.15))
	{
		if(m_armAngleIntakeReset)
		{
			m_armAngleIntakeCommand->Start();
			m_armAngleIntakeReset = false;
		}
	}
	else if((leftTrigger > 0.15) && (rightTrigger < 0.15)){
		if(m_armAngleIntakeReset)
				{
					m_armAngleIntakeCommand->Start();
					m_armAngleIntakeReset = false;
				}
	}
	else
	{
		//Trigger has been released
		m_armAngleIntakeReset = true;
	}



	if((rightTrigger > .15) && !ballDetected){
		intake.get()->SetSecondaryOn();
	}
	else {
		if (aButton){ //a pressed
			intake.get()->SetSecondaryOn();
		}
		else if (xButton){ //x pressed
			intake.get()->SetSecondaryOut();

		}
		else {
			intake.get()->SetSecondaryOff();
		}
	}

	if((rightTrigger > .15)){
		intake.get()->SetIntakeOn();
	}
	else if(leftTrigger > .15){
		intake.get()->SetIntakeOut();
		}
	else {
		intake.get()->SetIntakeOff();
	}

	//Drive
//
//	float leftDrive = oi.get()->getDriverJoystick()->GetRawAxis(1);
//	float rightDrive = oi.get()->getDriverJoystick()->GetRawAxis(5); //tank drive, currently disabled for arcade drive
//	drivePID.get()->robotDrive41.get()->TankDrive(leftDrive, rightDrive);
//
//	std::cout << "\tLeft Drive " << leftDrive << "\tRight Drive " << rightDrive;

	//double intakeButton = oi.get()->getDriverJoystick()->GetRawAxis(3);


//	/*std::cout << "Distance = " << */drivePID.get()->GetDistanceTraveled()/* << std::endl*/;
//
	float arcadeDrive = oi.get()->getDriverJoystick()->GetRawAxis(1);
	float arcadeTurn = oi.get()->getDriverJoystick()->GetRawAxis(4);
	drivePID.get()->robotDrive41.get()->ArcadeDrive(-arcadeDrive, arcadeTurn);
//
//	std::cout << "\tArcade Drive : " << arcadeDrive << "\tArcadeTurn : " << arcadeTurn;
//

	//GRAPPLECLIMB

//	bool buttonY = oi.get()->getOperatorJoystick()->GetRawButton(4); // climb deploy bc i haven't written a command yet
////	bool buttonB = oi.get()->getOperatorJoystick()->GetRawButton(2);
//
//	if(buttonY){
//		grappleClimb.get()->SetClimbState(Climb_Deploy);
//	}
//	else {
//		grappleClimb.get()->SetClimbState(Climb_Release);
//	}

	//Arm

	//bool rightButton = oi->getDriverJoystick()->GetRawButton(6);
	float armMotorPower = oi.get()->getOperatorJoystick()->GetRawAxis(1);
	bool override = oi.get()->getOperatorJoystick()->GetRawButton(8);

	if((fabs(armMotorPower) > .15)){
		armPID.get()->ManualArmControl(armMotorPower, override);
		m_armWasActive = true;
	}
	else if(m_armWasActive)
	{
		m_armWasActive = false;
		armPID.get()->ManualArmControl(0, false);
	}
	else {
		m_armAngleIntakeReset = true;
	}


	float longAngle = oi->getOperatorJoystick()->GetRawAxis(3);
	float shortAngle = oi->getOperatorJoystick()->GetRawAxis(2);
	if (fabs(longAngle) > .15) {
		if(m_triggerHoodReset)
		{
			m_triggerHoodMedium->Start();
			shooterWheelPID.get()->SetSequenceSpeed(Long_Shot_Angle);
			m_triggerHoodReset = false;
		}
		shooterTurretPID.get()->SetTurretCylinder(Turret_Angled);
		// same as FireSequence(Hood_Medium, Turret_Angled, Long_Shot);
	}
	else if (fabs(shortAngle) > .15){
		if(m_triggerHoodReset)
		{
			m_triggerHoodHigh->Start();
			shooterWheelPID.get()->SetSequenceSpeed(Short_Shot);
			m_triggerHoodReset = false;
		}
		shooterTurretPID.get()->SetTurretCylinder(Turret_Angled);
		// same as FireSequence(Hood_Stow, Turret_Angled, Short_Shot);
	}
	else {
		if(!m_triggerHoodReset)
		{
			m_triggerHoodStow->Start();
			shooterWheelPID.get()->SetSequenceSpeed(Idle_Shot);
			m_triggerHoodReset = true;
		}
		shooterTurretPID.get()->SetTurretCylinder(Turret_Straight);
	}

	//std::cout<<", \tShooter Wheel Speed" << Robot::shooterWheelPID.get()->ReturnPIDInput()<<std::endl;

	//if(m_armAngleIntakeCommand)

			//<< ", \tShooter Wheel " << RobotMap::shooterWheelPIDSpeedCounter.get()->Get();

	//Turret -- operator

//	double turretPosition = oi.get()->getOperatorJoystick()->GetRawAxis(4);
//	//shooterTurretPID.get()->SetTurretPosition(turretPosition/2);
//	RobotMap::shooterTurretPIDTurretMotor.get()->Set(turretPosition/2);
//
//	if(ballDetected){
//		armPID.get()->SetArmLightsPurple();
//	}
//	else{
//		armPID.get()->SetArmLights(Light_Off);
//	}

	std::cout << std::endl;


	Wait(.005);



}

void Robot::TestPeriodic() {
	lw->Run();
}

START_ROBOT_CLASS(Robot);

